import 'package:flutter/material.dart';
import 'package:holink/features/parish/scheduling/model/regularEvent.dart';
import 'package:holink/features/parish/scheduling/model/regularEventDate.dart';
import 'package:http/http.dart' as http;
import 'package:holink/dbConnection/localhost.dart';

class RegularEventForm extends StatefulWidget {
  const RegularEventForm({super.key});

  @override
  _RegularEventFormState createState() => _RegularEventFormState();
}

class _RegularEventFormState extends State<RegularEventForm> {
  final _formKey = GlobalKey<FormState>();
  final _eventNameController = TextEditingController();
  final _descriptionController = TextEditingController();
  final _priestIdController = TextEditingController();
  final _lectorIdController = TextEditingController();
  final _sacristanIdController = TextEditingController();
  final _regularEventController = TextEditingController();
  final _addressController = TextEditingController();
  localhost localhostInstance = localhost();

  Future<bool> saveRegularEvent(RegularEvent event) async {
    final url = Uri.parse(
        'http://${localhostInstance.ipServer}/dashboard/myfolder/scheduling/saveRegularEvent.php');
    final response = await http.post(
      url,
      headers: {'Content-Type': 'application/json'},
    );

    return response.statusCode ==
        201; // Assuming 201 is the success status code
  }

  Future<bool> saveRegularEventDate(RegularEventDate eventDate) async {
    final url = Uri.parse(
        'http://${localhostInstance.ipServer}/dashboard/myfolder/scheduling/saveRegularEventDate.php');
    final response = await http.post(
      url,
      headers: {'Content-Type': 'application/json'},
    );

    return response.statusCode ==
        201; // Assuming 201 is the success status code
  }

  final List<DateTime> _selectedDates = [];
  final List<String> _repeatOptions = [
    "Every Monday",
    "Every Tuesday",
    "Every Wednesday",
    "Every Thursday",
    "Every Friday",
    "Every Saturday",
    "Every Sunday"
  ];
  final Map<String, List<TimeOfDay>> _selectedRepeatOptions = {};
  final Map<DateTime, TimeOfDay> _specificDatesWithTimes = {};
  String? _selectedRepeatOption;
  int _selectedMonth = DateTime.now().month;

  @override
  void dispose() {
    _eventNameController.dispose();
    _descriptionController.dispose();
    _priestIdController.dispose();
    _lectorIdController.dispose();
    _sacristanIdController.dispose();
    _regularEventController.dispose();
    _addressController.dispose();
    super.dispose();
  }

  Future<void> _selectDate(BuildContext context) async {
    final picked = await showDatePicker(
        context: context,
        initialDate: DateTime.now(),
        firstDate: DateTime.now(),
        lastDate: DateTime(2101));

    if (picked != null &&
        picked.month == _selectedMonth &&
        !_selectedDates.contains(picked)) {
      final time =
          await showTimePicker(context: context, initialTime: TimeOfDay.now());
      if (time != null) {
        setState(() {
          _selectedDates.add(picked);
          _specificDatesWithTimes[picked] = time;
        });
      }
    }
  }

  Future<void> _selectTime(BuildContext context, String day) async {
    final picked =
        await showTimePicker(context: context, initialTime: TimeOfDay.now());
    if (picked != null) {
      setState(() {
        _selectedRepeatOptions.putIfAbsent(day, () => []).add(picked);
      });
      _generateRepeatDates(day, picked);
    }
  }

  void _generateRepeatDates(String day, TimeOfDay time) {
    final now = DateTime.now();
    final daysInMonth = DateTime(now.year, _selectedMonth + 1, 0).day;
    final dayNumber = _dayStringToNumber(day);

    final newDates = List.generate(daysInMonth, (i) {
      final date = DateTime(now.year, _selectedMonth, i + 1);
      return date.weekday == dayNumber
          ? DateTime(date.year, date.month, date.day, time.hour, time.minute)
          : null;
    }).whereType<DateTime>().toList();

    setState(() {
      _selectedDates.addAll(newDates);
      for (var date in newDates) {
        _specificDatesWithTimes[date] = time;
      }
    });
  }

  void _plotForm() async {
    if (_formKey.currentState!.validate()) {
      // Create a new RegularEvent object
      RegularEvent event = RegularEvent(
        id: 0, // This should be generated by the backend
        eventName: _eventNameController.text,
        description: _descriptionController.text,
        address: _addressController.text,
      );

      // Save the RegularEvent object
      bool eventSaved = await saveRegularEvent(event);

      if (eventSaved) {
        // Save each RegularEventDate
        for (DateTime date in _selectedDates) {
          RegularEventDate eventDate = RegularEventDate(
            id: 0, // This should be generated by the backend
            eventDate: date,
            priestId: int.tryParse(_priestIdController.text),
            lectorId: int.tryParse(_lectorIdController.text),
            sacristanId: int.tryParse(_sacristanIdController.text),
            regularEvent: event.id,
          );

          await saveRegularEventDate(eventDate);
        }

        // Process the form data here with _selectedDates
        Navigator.pop(context);
      } else {
        // Handle the error
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
          content: Text('Failed to save the event.'),
        ));
      }
    }
  }

  int _dayStringToNumber(String day) {
    const days = {
      "Every Monday": DateTime.monday,
      "Every Tuesday": DateTime.tuesday,
      "Every Wednesday": DateTime.wednesday,
      "Every Thursday": DateTime.thursday,
      "Every Friday": DateTime.friday,
      "Every Saturday": DateTime.saturday,
      "Every Sunday": DateTime.sunday,
    };
    return days[day] ?? 1;
  }

  @override
  Widget build(BuildContext context) {
    final now = DateTime.now();
    return Scaffold(
      appBar: AppBar(
        automaticallyImplyLeading: false,
        title: const Center(
            child: Text('Create Regular Event',
                style: TextStyle(color: Colors.white))),
        backgroundColor: const Color.fromRGBO(179, 120, 64, 1.0),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Form(
          key: _formKey,
          child: SingleChildScrollView(
            child: Column(
              children: [
                _buildDropdownField<int>(
                  "Select Month",
                  _selectedMonth,
                  List.generate(12 - now.month + 1, (index) {
                    return DropdownMenuItem(
                      value: now.month + index,
                      child: Text(_monthName(now.month + index),
                          style: const TextStyle(color: Colors.black54)),
                    );
                  }),
                  (newValue) {
                    setState(() {
                      _selectedMonth = newValue!;
                      _selectedDates.clear();
                      _specificDatesWithTimes.clear();
                    });
                  },
                ),
                const SizedBox(height: 16.0),
                _buildTextField(_eventNameController, 'Event Name'),
                const SizedBox(height: 16.0),
                _buildTextField(_descriptionController, 'Description'),
                const SizedBox(height: 16.0),
                _buildTextField(_addressController, 'Address'),
                const SizedBox(height: 16.0),
                _buildDropdownField<String>(
                  "Select Repeat Option",
                  _selectedRepeatOption,
                  _repeatOptions.map((value) {
                    return DropdownMenuItem<String>(
                      value: value,
                      child:
                          Text(value, style: const TextStyle(color: Colors.black54)),
                    );
                  }).toList(),
                  (newValue) {
                    setState(() {
                      _selectedRepeatOption = newValue;
                    });
                    if (newValue != null) _selectTime(context, newValue);
                  },
                ),
                const SizedBox(height: 16.0),
                _buildSelectedRepeatOptions(),
                const SizedBox(height: 16.0),
                ElevatedButton(
                  onPressed: () => _selectDate(context),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: const Color.fromRGBO(179, 120, 64, 1.0),
                    foregroundColor: Colors.white,
                  ),
                  child: const Text("Select Specific Dates"),
                ),
                _buildSelectedDatesChips(),
                const SizedBox(height: 16.0),
                _buildActionButtons(),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildDropdownField<T>(String labelText, T? value,
      List<DropdownMenuItem<T>> items, ValueChanged<T?> onChanged) {
    return DropdownButtonFormField<T>(
      value: value,
      items: items,
      onChanged: onChanged,
      decoration: _inputDecoration(labelText),
    );
  }

  Widget _buildTextField(TextEditingController controller, String labelText,
      {TextInputType keyboardType = TextInputType.text}) {
    return TextFormField(
      controller: controller,
      decoration: _inputDecoration(labelText),
      keyboardType: keyboardType,
      validator: (value) =>
          value == null || value.isEmpty ? 'Please enter $labelText' : null,
    );
  }

  InputDecoration _inputDecoration(String labelText) {
    return InputDecoration(
      labelText: labelText,
      labelStyle: const TextStyle(color: Colors.black54),
      border: const OutlineInputBorder(
          borderRadius: BorderRadius.all(Radius.circular(10)),
          borderSide: BorderSide(color: Colors.black54)),
      enabledBorder: const OutlineInputBorder(
          borderRadius: BorderRadius.all(Radius.circular(10)),
          borderSide: BorderSide(color: Colors.black54)),
      focusedBorder: const OutlineInputBorder(
          borderRadius: BorderRadius.all(Radius.circular(10)),
          borderSide: BorderSide(color: Colors.black54)),
    );
  }

  Widget _buildSelectedRepeatOptions() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: _selectedRepeatOptions.entries.expand((entry) {
        return entry.value.map((time) {
          return Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text("${entry.key} at ${time.format(context)}",
                  style: const TextStyle(fontSize: 16, color: Colors.black87)),
              IconButton(
                icon: const Icon(Icons.delete, color: Colors.red),
                onPressed: () {
                  setState(() {
                    _selectedRepeatOptions[entry.key]!.remove(time);
                    if (_selectedRepeatOptions[entry.key]!.isEmpty) {
                      _selectedRepeatOptions.remove(entry.key);
                    }
                    _selectedDates.removeWhere((date) =>
                        date.weekday == _dayStringToNumber(entry.key) &&
                        date.hour == time.hour &&
                        date.minute == time.minute);
                    _specificDatesWithTimes.removeWhere((date, t) =>
                        date.weekday == _dayStringToNumber(entry.key) &&
                        date.hour == time.hour &&
                        date.minute == time.minute);
                  });
                },
              ),
            ],
          );
        });
      }).toList(),
    );
  }

  Widget _buildSelectedDatesChips() {
    return Wrap(
      spacing: 8.0,
      runSpacing: 4.0,
      children: _selectedDates.map((date) {
        return InputChip(
          label: Text("${"${date.toLocal()}".split(' ')[0]} at ${_specificDatesWithTimes[date]?.format(context) ?? ""}"),
          labelStyle: const TextStyle(color: Colors.black87),
          onDeleted: () {
            setState(() {
              _selectedDates.remove(date);
              _specificDatesWithTimes.remove(date);
            });
          },
          onPressed: () => _editDateTime(context, date),
        );
      }).toList(),
    );
  }

  void _editDateTime(BuildContext context, DateTime date) async {
    final newDate = await showDatePicker(
      context: context,
      initialDate: date,
      firstDate: DateTime(2000),
      lastDate: DateTime(2101),
    );
    if (newDate != null) {
      final newTime = await showTimePicker(
        context: context,
        initialTime:
            _specificDatesWithTimes[date] ?? TimeOfDay.fromDateTime(date),
      );
      if (newTime != null) {
        setState(() {
          _selectedDates.remove(date);
          _specificDatesWithTimes.remove(date);
          _selectedDates.add(newDate);
          _specificDatesWithTimes[newDate] = newTime;
        });
      }
    }
  }

  String _monthName(int month) {
    const months = [
      'January',
      'February',
      'March',
      'April',
      'May',
      'June',
      'July',
      'August',
      'September',
      'October',
      'November',
      'December'
    ];
    return months[month - 1];
  }

  Widget _buildActionButtons() {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
      children: [
        ElevatedButton(
          onPressed: () => Navigator.pop(context),
          style: ElevatedButton.styleFrom(
            backgroundColor: Colors.red,
            foregroundColor: Colors.white,
          ),
          child: const Text('Cancel'),
        ),
        ElevatedButton(
          onPressed: _plotForm,
          style: ElevatedButton.styleFrom(
            backgroundColor: const Color(0xFF57CA63),
            foregroundColor: Colors.white,
          ),
          child: const Text('Plot'),
        ),
      ],
    );
  }
}
